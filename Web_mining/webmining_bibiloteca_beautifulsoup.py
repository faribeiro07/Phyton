# -*- coding: utf-8 -*-
"""WebMining - Bibiloteca BeautifulSoup

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VjVFHw-ziNUW5B-rn-hAoKl713X72s60

# Biblioteca BeautifulSoup

Usada para explorar elementos de um website
"""

from bs4 import BeautifulSoup
import requests
import re

init = 'https://pt.wikipedia.org/wiki/Intelig%C3%AAncia_artificial'

response = requests.get(init) #variável para obter estrutura html do site
bs = BeautifulSoup(response.text, 'html.parser') #variável para estruturar conteúdo carregado anteriormente.
bs

bs('h1') #retorna uma lista com todos os marcadores solicitados

#bs(name, attrs, recursive, string, limit, **kwargs) sintaxe do BeuatifulSoup

bs(re.compile('h\d')) #re.compile está pesquisando com expressão regulares para obter todos os marcadores h

bs(attrs={'id':'footer'}) #pesquisando por atributos que contenham footer

bs(attrs={'class':'hatnote'}) #pesquisando por atributos pela classe

bs(attrs={'class':'mw-redirect', 'title':'Wikipedia'}) #pesquisa de atributos com duas condições

bs(title='Wikipedia') #pesquisa com **kwargs, onde é possível pesquisar direto pelo marcador.

#**kwargs não válido para o atributo
    # name, pois a name é parametro da biblioteca. Nesse caso, recomenda-se a busca com attrs=
    # com hifen, pois a construção não é lida no phyton. Nesse caso, recomenda-se a busca com attrs=
    # class, pois essa é uma palavra reservada do phyton. No entanto, pode-se usar o parametro class_

bs(title='Wikipedia', class_='mw-redirect') #Pesquisa **kwargs e uso do atributo class_

bs('div', class_='hatnote') #outro exemplo de pesquisa **kwargs e uso do atributo class_

bs('div', class_='hatnote', limit=1) #parametro limit é para quantificar os resultados

#bs esse comando retorna os informações pela raiz
#bs('a') retorna os elementos desde a rai\

bs('a', recursive=False) #parametro recursive delimita a seção da página em que ocorrerá a busca

bodyc = bs(id='bodyContent')[0] #lista com tudo que estiver na seção bodyContent
links = bodyc('a', recursive=False) #como a variável é do mesmo tipo de objeto do bs, então é possível usar recursos para filtrá-lo. O recusive = False retornará apenas os links dentro da seção bodyContent
links

bs(string='Física') #retorna o texto exato pesquisado: Física

bs('a', string='Física') #retorna o marcador onde tenha o texto exato: Física

bs('a', string=re.compile('Física')) #retorna qualquer registro que contenha a palavra Física

print(bs.text) #retorna os conteúdos que estão dentro dos marcadores. O print fará a interpretaçção das quebras de linhas

for r in bs(['script', 'style']): #comando para remover os marcadores script e style do conteúdo que será interpretado. A Lista permite adicionar mais marcadores
  r.extract()
print(bs.text)

for r in bs(['script', 'style',re.compile('h\d'), 'title']): #Além dos marcadores script e style, os heads (h1, h2...), também serão removidos
  r.extract()
print(bs.text)